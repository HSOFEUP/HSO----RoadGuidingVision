.\" Automatically generated by Pod::Man 2.25 (Pod::Simple 3.16)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "lmmin 3"
.TH lmmin 3 "2013-07-16" "perl v5.14.2" "lmfit manual"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
lmmin \- Levenberg\-Marquardt least\-squares minimization
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
\&\fB#include <lmmin.h\fR>
.PP
\&\fBvoid lmmin( int\fR \fIn_par\fR\fB, double *\fR\fIpar\fR\fB, int\fR \fIm_dat\fR\fB, const\ void *\fR\fIdata\fR\fB,
            void (*\fR\fIevaluate\fR\fB)(
                const\ double *\fR\fIpar\fR\fB, int \fR\fIm_dat\fR\fB, const\ void *\fR\fIdata\fR\fB,
                double *\fR\fIfvec\fR\fB, int *\fR\fIinfo\fR\fB ),
            void (*\fR\fIprintout\fR\fB)(
                int\fR \fIn_par\fR\fB, const\ double *\fR\fIpar\fR\fB, int \fR\fIm_dat\fR\fB,
                const\ void *\fR\fIdata\fR\fB, double *\fR\fIfvec\fR\fB, 
                const\ lm_princon_struct *\fR\fIprincon\fR\fB,
                int \fR\fIiflag\fR\fB, int \fR\fIiter\fR\fB, int \fR\fInfev\fR\fB ),
            const\ lm_control_struct *\fR\fIcontrol\fR\fB,
            const\ lm_princon_struct *\fR\fIprincon\fR\fB,
            lm_status_struct *\fR\fIstatus\fR\fB );\fR
.PP
\&\fBvoid lm_printout_std(
            int \fR\fIn_par\fR\fB, const\ double *\fR\fIpar\fR\fB, int \fR\fIm_dat\fR\fB,
            const\ void *\fR\fIdata\fR\fB, double *\fR\fIfvec\fR\fB, 
            const\ lm_princon_struct *\fR\fIprincon\fR\fB,
            int \fR\fIiflag\fR\fB, int \fR\fIiter\fR\fB, int \fR\fInfev\fR\fB );\fR
.PP
\&\fBextern const lm_control_struct lm_control_double;\fR
.PP
\&\fBextern const lm_control_struct lm_control_float;\fR
.PP
\&\fBextern const lm_princon_struct lm_princon_std;\fR
.PP
\&\fBextern const char *lm_infmsg[];\fR
.PP
\&\fBextern const char *lm_shortmsg[];\fR
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fB\f(BIlmmin()\fB\fR determines a vector \fIpar\fR that minimizes the sum of squared elements of a vector \fIfvec\fR that is computed by a user-supplied function \fIevaluate\fR().
On success, \fIpar\fR represents a local minimum, not necessarily a global one; it may depend on its starting value.
.PP
For applications in curve fitting, the wrapper function \fB\f(BIlmcurve\fB\|(3)\fR offers a simplified \s-1API\s0.
.PP
The Levenberg-Marquardt minimization starts with a steepest-descent exploration of the parameter space, and achieves rapid convergence by crossing over into the Newton-Gauss method. For more background, see MorA\*~X 1978, Madsen et al. 2004, and comments in the source code.
.PP
Function arguments:
.IP "\fIn_par\fR" 4
.IX Item "n_par"
Number of free variables. Dimension of parameter vector \fIpar\fR.
.IP "\fIpar\fR" 4
.IX Item "par"
Parameter vector. On input, it must contain a reasonable guess; on output, it contains the solution found to minimize ||\fIfvec\fR||.
.IP "\fIm_dat\fR" 4
.IX Item "m_dat"
Dimension of vector \fIfvec\fR.
Must statisfy \fIn_par\fR <= \fIm_dat\fR.
.IP "\fIdata\fR" 4
.IX Item "data"
This pointer is ignored by the fit algorithm,
except for appearing as an argument in all calls to the user-supplied
routines \fIevaluate\fR and \fIprintout\fR.
.IP "\fIevaluate\fR" 4
.IX Item "evaluate"
Pointer to a user-supplied function that computes \fIm_dat\fR elements of vector \fIfvec\fR for a given parameter vector \fIpar\fR. If \fIevaluate\fR return with *\fIinfo\fR set to a negative value, \fB\f(BIlmmin()\fB\fR will interrupt the fitting and terminate.
.IP "\fIprintout\fR" 4
.IX Item "printout"
A function that prints messages about the fit progress. Legitimate values of this pointer argument are \s-1NULL\s0 (to indicate that no messages are wanted), &\fIlm_printout_std\fR (pointer to a default implementation), or a pointer to a user-supplied function.
.IP "\fIcontrol\fR" 4
.IX Item "control"
Parameter collection for tuning the fit procedure.
In most cases, the default &\fIlm_control_double\fR is adequate.
If \fIf\fR is only computed with single-precision accuracy,
\&\fI&lm_control_float\fR should be used.
See also below, \s-1NOTES\s0 on initializing parameter records.
.Sp
\&\fIcontrol\fR has the following members (for more details, see the source file \fIlmstruct.h\fR):
.RS 4
.IP "\fBdouble\fR \fIcontrol.ftol\fR" 4
.IX Item "double control.ftol"
Relative error desired in the sum of squares; recommended setting: somewhat above machine precision; less if \fIfvec\fR is computed with reduced accuracy.
.IP "\fBdouble\fR \fIcontrol.xtol\fR" 4
.IX Item "double control.xtol"
Relative error between last two approximations; recommended setting: as \fIftol\fR.
.IP "\fBdouble\fR \fIcontrol.gtol\fR" 4
.IX Item "double control.gtol"
A measure for degeneracy; recommended setting: as \fIftol\fR.
.IP "\fBdouble\fR \fIcontrol.epsilon\fR" 4
.IX Item "double control.epsilon"
Step used to calculate the Jacobian; recommended setting: as \fIftol\fR, but definitely less than the accuracy of \fIfvec\fR.
.IP "\fBdouble\fR \fIcontrol.stepbound\fR" 4
.IX Item "double control.stepbound"
Initial bound to steps in the outer loop, generally between 0.01 and 100; recommended value is 100.
.IP "\fBint\fR \fIcontrol.patience\fR" 4
.IX Item "int control.patience"
Used to set the maximum number of function evaluations to patience*n_par.
.IP "\fBint\fR \fIcontrol.scale_diag\fR" 4
.IX Item "int control.scale_diag"
Logical switch (0 or 1). If 1, then scale parameters to their initial value. This is the recommended setting.
.IP "\fBint\fR \fIcontrol.pivot\fR" 4
.IX Item "int control.pivot"
Logical switch (0 or 1). If 1, then use pivots in matrix operations. This is the recommended setting.
.RE
.RS 4
.RE
.IP "\fIprincon\fR" 4
.IX Item "princon"
Parameter collection for tuning the default printout function
&\fIlm_printout_std\fR
(user-supplied printout functions are free to use this record or not).
For values \s-1NULL\s0 or &\fIlm_princon_def\fR, the fit is silent. 
See also below, \s-1NOTES\s0 on initializing parameter records.
.Sp
\&\fIprincon\fR has the following members:
.RS 4
.IP "\fBFILE**\fR \fIprincon.stream\fR" 4
.IX Item "FILE** princon.stream"
Pointer to the stream the output shall be writen to. Typically &\fIstdout\fR or &\fIstderr\fR.
.IP "\fBint\fR \fIprincon.form\fR" 4
.IX Item "int princon.form"
To select one out of several forms. In \fIlm_princon_def\fR, form=0 yields verbose output, form=1 yields one compact line per call.
.IP "\fBint\fR \fIprincon.flags\fR" 4
.IX Item "int princon.flags"
\&\s-1OR\s0'ed bit values to print (1) status, (2) parameters and norm, (4) residues at end of fit, (8) residues at every step;
.IP "\fBint\fR \fIprincon.n_maxpri\fR" 4
.IX Item "int princon.n_maxpri"
\&\-1, or maximum number of parameters to print.
.IP "\fBint\fR \fIprincon.m_maxpri\fR" 4
.IX Item "int princon.m_maxpri"
\&\-1, or maximum number of residuals to print.
.RE
.RS 4
.RE
.IP "\fIstatus\fR" 4
.IX Item "status"
A record used to return information about the minimization process:
.RS 4
.IP "\fBdouble\fR \fIstatus.fnorm\fR" 4
.IX Item "double status.fnorm"
Norm of the vector \fIfvec\fR;
.IP "\fBint\fR \fIstatus.nfev\fR" 4
.IX Item "int status.nfev"
Actual number of iterations;
.IP "\fBint\fR \fIstatus.info\fR" 4
.IX Item "int status.info"
Status of minimization;
for the corresponding text message, print \fIlm_infmsg\fR\fB[\fR\fIstatus.info\fR\fB]\fR;
for a short code, print \fIlm_shortmsg\fR\fB[\fR\fIstatus.info\fR\fB]\fR.
.RE
.RS 4
.RE
.SH "NOTES"
.IX Header "NOTES"
.SS "Initializing parameter records."
.IX Subsection "Initializing parameter records."
The parameter records \fIcontrol\fR and \fIprincon\fR should always be initialized
from supplied default records:
.PP
.Vb 2
\&    lm_control_struct control = lm_control_double; /* or _float */
\&    lm_princon_struct princon = lm_princon_std;
.Ve
.PP
After this, parameters may be overwritten:
.PP
.Vb 2
\&    control.patience = 500; /* allow more iterations */
\&    princon.flags    =  15; /* require most verbose monitoring */
.Ve
.PP
An application written this way is guaranteed to work even if new parameters
are added to \fIcontrol\fR or \fIprincon\fR.
.PP
Conversely, addition of parameters is not considered an \s-1API\s0 change; it may happen without increment of the major version number.
.SH "EXAMPLES"
.IX Header "EXAMPLES"
See directory \fIdemo/\fR in the source distribution.
.SS "One-dimensional curve fitting:"
.IX Subsection "One-dimensional curve fitting:"
See application sample \fIdemo/curve1.c\fR.
.SS "Fitting a function of a vectorial argument:"
.IX Subsection "Fitting a function of a vectorial argument:"
See application sample \fIdemo/surface1.c\fR.
.SS "Minimize the norm of a vectorial function:"
.IX Subsection "Minimize the norm of a vectorial function:"
Several application samples are provided;
they also serve as test suite to ascertain that the fit algorithm
overcomes well-known numerical problems:
.PP
\&\fIdemo/morobropro.c\fR: \fIm\fR=3, \fIn\fR=2, modified Rosenbrock problem, testing robustness for widely different vectorial components.
.PP
\&\fIdemo/powell.c\fR: \fIm\fR=2, \fIn\fR=2, Powell 1970, with singular Jacobian at the solution par=0.
.PP
\&\fIdemo/hat.c\fR: \fIm\fR=2, \fIn\fR=1, asymetric mexican hat function ||\fIF\fR(\fIp\fR)||. Fit result depends on starting value \- lmfit does not strive to overcome the limitation to local optimisation.
.SH "VERSIONS"
.IX Header "VERSIONS"
The first public release was 2.0 (December 2004). The \s-1API\s0 has changed with version 3.0 (March 2010), and again with version 4.0 (July 2013).
.SH "COPYING"
.IX Header "COPYING"
Copyright (C):
   1980\-1999 University of Chicago
   2004\-2013 Joachim Wuttke, Forschungszentrum Juelich GmbH
.PP
Software: FreeBSD License
.PP
Documentation: Creative Commons Attribution Share Alike
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\fBlmcurve\fR(3)
.PP
Homepage: http://apps.jcns.fz\-juelich.de/lmfit
.PP
Please report bugs to the author <j.wuttke@fz\-juelich.de>
